#!/usr/bin/env bash
set -euo pipefail

# efi-nuke — delete ALL UEFI NVRAM Boot#### entries (hex-safe)
# Default: dry-run. Use --apply to actually delete.
# Optional: --keep <IDCSV> (hex/ranges), --keep-pattern "REGEX"

apply=false
keep_ids_raw=""
keep_patterns=""

die(){ echo "error: $*" >&2; exit 1; }
command -v efibootmgr >/dev/null || die "efibootmgr not found"

hex_norm() {
  # Normalize hex like "a", "000a", "0xA" => "000A"
  local x="${1^^}"; x="${x#0X}"
  # empty guard
  [[ -n "$x" ]] || { echo "0000"; return; }
  printf "%04X" "$((16#$x))"
}

parse_id_list() {
  # Convert CSV/ranges like "0000,1,2001-2003" => "0000 0001 2001 2002 2003"
  local in="$1" out="" tok a b
  IFS=',' read -ra parts <<< "$in"
  for tok in "${parts[@]}"; do
    tok="${tok// /}"; [[ -z "$tok" ]] && continue
    if [[ "$tok" =~ ^([0-9A-Fa-fx]+)-([0-9A-Fa-fx]+)$ ]]; then
      a="$(hex_norm "${BASH_REMATCH[1]}")"
      b="$(hex_norm "${BASH_REMATCH[2]}")"
      local ai=$((16#$a)) bi=$((16#$b)) i
      if (( ai <= bi )); then
        for ((i=ai;i<=bi;i++)); do out+=" $(printf "%04X" "$i")"; done
      else
        for ((i=ai;i>=bi;i--)); do out+=" $(printf "%04X" "$i")"; done
      fi
    else
      out+=" $(hex_norm "$tok")"
    fi
  done
  echo "$out"
}

# args
while (($#)); do
  case "$1" in
    --apply) apply=true;;
    --keep) shift; keep_ids_raw="${1:-}";;
    --keep-pattern|--keep-patterns) shift; keep_patterns="${1:-}";;
    -h|--help)
      cat <<'EOF'
efi-nuke — delete ALL UEFI NVRAM Boot#### entries (hex-safe)

Usage:
  efi-nuke [--apply] [--keep IDCSV] [--keep-pattern REGEX]

Examples:
  efi-nuke --apply
  efi-nuke --keep 2001-2003
  efi-nuke --keep-pattern "USB|Network"

Notes:
  - IDs are hexadecimal (0000–FFFF). Accepts short forms and ranges.
  - Without --apply this is a dry-run.
EOF
      exit 0;;
    *) die "unknown arg: $1";;
  esac; shift
done

# read efibootmgr
mapfile -t lines < <(sudo efibootmgr)

declare -A LABEL PATHS PRESENT
ids=()

for line in "${lines[@]}"; do
  if [[ "$line" =~ ^Boot([0-9A-Fa-f]{4})\*?\ (.*)$ ]]; then
    raw="${BASH_REMATCH[1]}"
    id="$(hex_norm "$raw")"          # normalize to 4-hex
    PRESENT["$id"]=1
    ids+=("$id")
    if [[ "$line" == *$'\t'* ]]; then
      lbl="${line#Boot${raw}}"; lbl="${lbl#\* }"; lbl="${lbl%%$'\t'*}"
      pth="${line#*$'\t'}"
    else
      lbl="${BASH_REMATCH[2]}"; pth=""
    fi
    # trim trailing spaces
    lbl="$(echo -e "$lbl" | sed 's/[[:space:]]*$//')"
    LABEL["$id"]="$lbl"
    PATHS["$id"]="$pth"
  fi
done

# build keep set
declare -A KEEP
if [[ -n "$keep_ids_raw" ]]; then
  for k in $(parse_id_list "$keep_ids_raw"); do KEEP["$k"]=1; done
fi
use_pat=false; [[ -n "$keep_patterns" ]] && use_pat=true

# compute deletion list
to_del=()
for id in "${ids[@]}"; do
  [[ -n "${KEEP[$id]:-}" ]] && continue
  if $use_pat && echo "${LABEL[$id]}"$'\n'"${PATHS[$id]}" | grep -Eiq -- "$keep_patterns"; then
    continue
  fi
  to_del+=("$id")
done

# report
if ((${#ids[@]}==0)); then
  echo "No Boot#### entries found."
  exit 0
fi

echo "Discovered ${#ids[@]} Boot#### entries:"
for id in $(printf "%s\n" "${ids[@]}" | sort); do
  mark=""
  for k in "${to_del[@]}"; do [[ "$k" == "$id" ]] && { mark="[DEL]"; break; }; done
  printf "  %-5s %-4s  %s\n" "$mark" "$id" "${LABEL[$id]}"
done
echo

if ((${#to_del[@]}==0)); then
  echo "Nothing to delete (all kept by rules)."
  exit 0
fi

if ! $apply; then
  echo "Dry-run: would delete ${#to_del[@]} entr$( (( ${#to_del[@]}==1 )) && echo "y" || echo "ies" )."
  exit 0
fi

echo "Deleting ${#to_del[@]} entries..."
for id in "${to_del[@]}"; do
  # IMPORTANT: pass hex string directly; efibootmgr expects hex
  echo "  efibootmgr -q -B -b $id   # (${LABEL[$id]})"
  sudo efibootmgr -q -B -b "$id"
done

echo "Done."
